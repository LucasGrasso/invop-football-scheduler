# -*- coding: utf-8 -*-
"""football.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A9shLtzKXwLNWW9aXx7jyeLNqvgM9JIR
"""

!pip install -q condacolab
import condacolab
condacolab.install_from_url("https://github.com/conda-forge/miniforge/releases/download/25.3.1-0/Miniforge3-Linux-x86_64.sh")

!conda install -q pyscipopt

from pyscipopt import Model, quicksum
from enum import Enum
from typing import List


class SymetricScheme(Enum):
    MIRRORED = 0
    FRENCH = 1
    ENGLISH = 2
    INVERTED = 3
    BACK_TO_BACK = 4
    MIN_MAX = 5


def create_football_scheduler_model(
    N: int,
    scheme: SymetricScheme,
    I_s: List[int] = [],
    c: int = 0,
    d: int = 0,
):
    """
    Create and configure a SCIP model for the Football Scheduling problem.

    Args:
        N (int): Number of teams (must be even).
        scheme (SymetricScheme): Symmetric scheme to be used.
        I_s (list[int]): List of top teams. Should be a subset of teams {0, 1, ..., N-1}. Defaults to [].
        c (int, optional): Parameter c for MIN_MAX scheme. Defaults to 0.
        d (int, optional): Parameter d for MIN_MAX scheme. Defaults to 0.

    Returns:
        pyscipopt.Model: The configured SCIP model.
    """
    if N % 2 != 0:
        raise ValueError("N is not even")
    if len(I_s) > 0 and (max(I_s)) > N:
        raise ValueError("I_s must be a subset of teams I")
    if scheme != SymetricScheme.MIN_MAX and (c != 0 or d != 0):
        raise ValueError("c and d should not be provided for schemes other than MIN_MAX")
    if scheme == SymetricScheme.MIN_MAX and (not (1 <= c <= N) or not (c <= d <= 2 * (N - 1))):
        raise ValueError("Invalid values for c and d")

    model = Model("Football Scheduler")
    K = 2 * (N - 1)  # total rounds (double round-robin)

    # Decision variables
    x = {}  # x[i,j,k] = 1 if i hosts j in round k
    y = {}  # H-A sequence indicators (per double round)
    w = {}  # away-break indicators (per double round)

    for i in range(N):
        for j in range(N):
            for k in range(K):
                x[i, j, k] = model.addVar(vtype="B", name=f"x_{i}_{j}_{k}")

    for i in range(N):
        for k in range(K):
            y[i, k] = model.addVar(vtype="B", name=f"y_{i}_{k}")
            w[i, k] = model.addVar(vtype="B", name=f"w_{i}_{k}")

    # --- Double round-robin constraints ---
    for i in range(N):
        for j in range(N):
            if i == j:
                continue

            # (1) each pair meets exactly once in the first half (rounds 0..N-2)
            model.addCons(
                quicksum(x[i, j, k] + x[j, i, k] for k in range(0, N - 1)) == 1,
                name=f"match_first_half_{i}_{j}",
            )

            # (2) each pair meets exactly once in the second half (rounds N-1..K-1)
            model.addCons(
                quicksum(x[i, j, k] + x[j, i, k] for k in range(N - 1, K)) == 1,
                name=f"match_second_half_{i}_{j}",
            )

            # (3) exactly one of the two games is at i's home
            model.addCons(
                quicksum(x[i, j, k] for k in range(K)) == 1,
                name=f"not_two_home_half_{i}_{j}",
            )

    # --- Compactness (one match per team per round) ---
    for j in range(N):
        for k in range(K):
            model.addCons(
                quicksum(x[i, j, k] + x[j, i, k] for i in range(N) if i != j) == 1,
                name=f"one_match_per_round_{j}_{k}",
            )

    # --- Top-teams: no consecutive matches vs top teams for non-top teams ---
    if len(I_s) > 0:
        for i in [t for t in range(N) if t not in I_s]:
            for k in range(K - 1):
                for j in I_s:
                    model.addCons(
                        x[i, j, k] + x[j, i, k] + x[i, j, k + 1] + x[j, i, k + 1] <= 1,
                        name=f"top_team_cons_{i}_{j}_{k}",
                    )

    # --- Balance constraints (H-A sequences per double round) ---
    for i in range(N):
        # bounds on number of H-A sequences
        model.addCons(quicksum(y[i, k] for k in range(0, K, 2)) >= (N // 2) - 1, name=f"bound_below_HA_seq_{i}")
        model.addCons(quicksum(y[i, k] for k in range(0, K, 2)) <= (N // 2), name=f"bound_above_HA_seq_{i}")

        for k in range(0, K, 2):
            # prohibit consecutive home/away within a double round unless counted by y
            model.addCons(
                quicksum(x[i, j, k] + x[j, i, k + 1] for j in range(N) if j != i) <= 1 + y[i, k],
                name=f"HA_{i}_{k}",
            )
            # y can't exceed played games
            model.addCons(quicksum(x[i, j, k] for j in range(N) if j != i) >= y[i, k], name=f"c8_{i}_{k}")
            model.addCons(quicksum(x[j, i, k + 1] for j in range(N) if j != i) >= y[i, k], name=f"c9_{i}_{k}")

    # --- Away-break auxiliaries per double round ---
    for i in range(N):
        for k in range(0, K, 2):
            model.addCons(
                quicksum(x[j, i, k] + x[j, i, k + 1] for j in range(N) if j != i) <= 1 + w[i, k],
                name=f"AB_{i}_{k}",
            )
            model.addCons(quicksum(x[j, i, k] for j in range(N) if j != i) >= w[i, k], name=f"c11_{i}_{k}")
            model.addCons(quicksum(x[j, i, k + 1] for j in range(N) if j != i) >= w[i, k], name=f"c12_{i}_{k}")

    # --- Symmetric schemes ---
    if scheme == SymetricScheme.MIRRORED:
        # shift by N-1 rounds (0-based)
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                for k in range(N - 1):
                    model.addCons(x[i, j, k] == x[j, i, k + (N - 1)], f"mirrored_{i}_{j}_{k}")

    elif scheme == SymetricScheme.FRENCH:
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                model.addCons(x[i, j, 0] == x[j, i, 2 * N - 3], f"french_1_{i}_{j}")
                for k in range(1, N - 1):
                    model.addCons(x[i, j, k] == x[j, i, k + (N - 2)], f"french_2_{i}_{j}_{k}")

    elif scheme == SymetricScheme.ENGLISH:
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                model.addCons(x[i, j, N - 2] == x[j, i, N - 1], f"english_1_{i}_{j}")
                for k in range(1, N - 2):
                    model.addCons(x[i, j, k] == x[j, i, k + N], f"english_2_{i}_{j}_{k}")

    elif scheme == SymetricScheme.INVERTED:
        # mirror around the end: index = (2*(N-1)-1) - k
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                for k in range(N - 1):
                    model.addCons(x[i, j, k] == x[j, i, (2 * (N - 1) - 1) - k], f"inverted_{i}_{j}_{k}")

    elif scheme == SymetricScheme.BACK_TO_BACK:
        # enforce on the first round of each double round: k = 0,2,4,...
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                for k in range(0, K, 2):
                    model.addCons(x[i, j, k] == x[j, i, k + 1], f"back_to_back_{i}_{j}_{k}")

    elif scheme == SymetricScheme.MIN_MAX:
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                # (19) at most one meeting within any window of length c+1
                for k in range(0, K - c):
                    model.addCons(
                        quicksum(x[i, j, q] + x[j, i, q] for q in range(k, k + c + 1)) <= 1,
                        f"min_max_1_{i}_{j}_{k}",
                    )
                # (20) spacing between home/away fixtures within distance d
                for k in range(0, K):
                    model.addCons(
                        quicksum(
                            x[i, j, q]
                            for q in range(max(k - d, 0), min(k + d + 1, 2 * (N - 1)))
                            if q != k
                        )
                        >= x[j, i, k],
                        f"min_max_2_{i}_{j}_{k}",
                    )

    # Objective: minimize total away breaks across all teams and double rounds
    model.setObjective(quicksum(w[i, k] for k in range(0, K, 2) for i in range(N)), sense="minimize")

    return model

# Example:
# model = create_football_scheduler_model(10, SymetricScheme.FRENCH, [1, 2])
# model.optimize()
# print("Objective value:", model.getObjVal())
# print("Solving time:", model.getSolvingTime())

# Known-feasible starter: ENGLISH + no top teams
N = 10
m = create_football_scheduler_model(N, SymetricScheme.ENGLISH, I_s=[])
m.optimize()

print("Status:", m.getStatus())
if m.getNSols() > 0:
    print("Obj:", m.getObjVal())
    nz = [v.name for v in m.getVars() if v.name.startswith("x_") and m.getVal(v) > 0.5]
    for name in sorted(nz, key=lambda s: int(s.split('_')[-1])):  # sort by round
        print(name)
else:
    print("No solutions → nothing to print (don’t call getVal).")

#hecho por chatgpt para que aparezca mas lindo y otras cosas
N = 6
top_teams = []                 # <— disable top-team constraint to avoid over-constraining
scheme = SymetricScheme.ENGLISH  # <— English symmetry tends to be easy/feasible

model = create_football_scheduler_model(N, scheme, top_teams)
model.optimize()

print("Status:", model.getStatus())
if model.getStatus() not in ("optimal", "timelimit", "gaplimit"):
    # Dump the LP for quick inspection if it's not solving to a solution
    model.writeProblem("football_model.lp")
    print("Wrote model to football_model.lp for debugging")
else:
    print("Objective value:", model.getObjVal())

# ---- Print the schedule as (i hosts j in round k) ----
print("\nMatches with x[i,j,k] = 1:")
nz = []
for var in model.getVars():  # getVars() returns a LIST
    name = var.name
    if name.startswith("x_"):
        val = model.getVal(var)
        if val is not None and val > 0.5:
            nz.append(name)
for name in sorted(nz, key=lambda s: int(s.split('_')[3])):  # sort by round k
    print(name)

# ---- Pretty table: Rounds x Teams (home=Hj, away=@j) ----
# Build a rounds x teams matrix indicating opponent and venue
K = 2*(N-1)
rounds = [[None]*N for _ in range(K)]

# Parse the x variables that are 1 to fill the table
for var in model.getVars():
    name = var.name
    if not name.startswith("x_"):
        continue
    val = model.getVal(var)
    if val is None or val < 0.5:
        continue
    _, si, sj, sk = name.split("_")
    i, j, k = int(si), int(sj), int(sk)
    # i hosts j in round k
    # For team i we mark "Hj" (home vs j), for team j we mark "@i" (away at i)
    rounds[k][i] = f"H{j}"
    rounds[k][j] = f"@{i}"

# Print the table
print("\nRound-by-round table (rows=rounds, cols=teams):")
header = "Round | " + "  ".join([f"T{t}" for t in range(N)])
print(header)
print("-"*len(header))
for k in range(K):
    row = [f"{rounds[k][t] if rounds[k][t] is not None else '--':>3}" for t in range(N)]
    print(f"{k:>5} | " + "  ".join(row))